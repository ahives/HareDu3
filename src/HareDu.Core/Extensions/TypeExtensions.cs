namespace HareDu.Core.Extensions;

using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections.Concurrent;

public static class TypeExtensions
{
    /// <summary>
    /// Determines whether the specified type is derived from the given base type.
    /// </summary>
    /// <param name="type">The type to check.</param>
    /// <param name="fromType">The base type to check against.</param>
    /// <returns>True if the specified type is derived from the given base type; otherwise, false.</returns>
    public static bool IsDerivedFrom(this Type type, Type fromType)
    {
        while (type is not null && type != typeof(object))
        {
            Type currentType = type.IsGenericType ? type.GetGenericTypeDefinition() : type;

            if (fromType == currentType)
                return true;

            type = type.BaseType;
        }

        return false;
    }

    /// <summary>
    /// Searches for a type within the array that matches the specified predicate.
    /// </summary>
    /// <param name="types">The array of types to search.</param>
    /// <param name="predicate">The condition to match against each type.</param>
    /// <returns>The first type that matches the predicate if found; otherwise, null.</returns>
    public static Type Find(this Type[] types, Predicate<Type> predicate) => Array.Find(types, predicate);

    /// <summary>
    /// Determines whether the given type implements a specified interface.
    /// </summary>
    /// <param name="type">The type to be checked for interface inheritance.</param>
    /// <param name="findType">The interface type to check against.</param>
    /// <returns>True if the given type implements the specified interface; otherwise, false.</returns>
    public static bool InheritsFromInterface(this Type type, Type findType) =>
        findType.IsGenericType
            ? type.GetInterfaces().Any(x => x.IsGenericType && x.GetGenericTypeDefinition() == findType)
            : type.GetInterfaces().Any(x => x == findType);

    /// <summary>
    /// Creates a dictionary mapping each type in the provided list to a key generated by the specified function.
    /// </summary>
    /// <param name="types">The list of types to map.</param>
    /// <param name="function">A function that generates a key for each type.</param>
    /// <returns>A dictionary where the key is the output of the specified function and the value is the corresponding type.</returns>
    public static Dictionary<string, Type> GetTypeMap(this List<Type> types, Func<Type, string> function)
    {
        var map = new Dictionary<string, Type>();

        foreach (var type in types)
        {
            string key = function(type);

            if (string.IsNullOrWhiteSpace(key) || !map.TryAdd(key, type))
                continue;
        }

        return map;
    }

    /// <summary>
    /// Attempts to register all types from the given map into the cache using the provided registration function.
    /// </summary>
    /// <param name="map">A dictionary containing type mappings where the key is a string representing the type and the value is the corresponding <see cref="Type"/>.</param>
    /// <param name="cache">The cache where the registrations will be stored.</param>
    /// <param name="register">A function that performs the registration of a type given the type and its associated key.</param>
    /// <typeparam name="T">The type of the objects stored in the cache.</typeparam>
    /// <returns>True if all keys in the map were successfully registered; otherwise, false.</returns>
    public static bool TryRegisterAll<T>(this IDictionary<string, Type> map, ConcurrentDictionary<string, T> cache, Func<Type, string, bool> register)
    {
        bool registered = true;

        foreach (var key in map.Keys.ToList())
        {
            if (cache.ContainsKey(key) || !map.TryGetValue(key, out Type type))
                continue;

            registered &= register(type, key);
        }

        return registered;
    }

    /// <summary>
    /// Attempts to register all types from the specified dictionary to the cache using the provided registration and instance creation functions.
    /// </summary>
    /// <param name="map">The dictionary containing type mappings with their corresponding keys.</param>
    /// <param name="cache">The concurrent dictionary representing the cache where types will be registered.</param>
    /// <param name="register">The function responsible for registering types into the cache.</param>
    /// <param name="instance">The function responsible for creating an instance of the specified type.</param>
    /// <typeparam name="T">The type of objects to be registered in the cache.</typeparam>
    /// <returns>True if all types were successfully registered; otherwise, false.</returns>
    public static bool TryRegisterAll<T>(this IDictionary<string, Type> map, ConcurrentDictionary<string, T> cache,
        Func<Type, string, Func<Type, T>, Func<string, T, bool>, bool> register, Func<Type, T> instance)
    {
        bool registered = true;

        foreach (var key in map.Keys.ToList())
        {
            if (cache.ContainsKey(key) || !map.TryGetValue(key, out Type type))
                continue;

            registered &= register(type, key, instance, cache.TryAdd);
        }

        return registered;
    }

    /// <summary>
    /// Determines whether any type in the array implements the specified interface.
    /// </summary>
    /// <param name="types">The array of types to check.</param>
    /// <param name="findType">The interface type to look for.</param>
    /// <returns>True if any type in the array implements the specified interface; otherwise, false.</returns>
    public static bool ImplementsInterface(this Type[] types, Type findType)
    {
        for (int i = 0; i < types.Length; i++)
            if (types[i] == findType)
                return true;

        return false;
    }
}